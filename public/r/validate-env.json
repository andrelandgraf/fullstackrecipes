{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "validate-env",
  "title": "Validate Environment",
  "description": "CLI script to validate all config.ts files against .env files. Finds missing variables, reports validation errors, and warns about unused env vars.",
  "dependencies": ["@next/env"],
  "registryDependencies": ["config-schema"],
  "files": [
    {
      "path": "scripts/validate-env.ts",
      "content": "#!/usr/bin/env bun\n/**\n * Validate environment configuration\n *\n * Usage:\n *   bun run validate-env\n *   bun run validate-env --environment=development\n *   bun run validate-env --environment=production\n *\n * This script:\n * 1. Loads env files using Next.js's loadEnvConfig\n * 2. Finds all config.ts files in src/lib/\\*\\/\n * 3. Validates each config by importing it (triggers configSchema validation)\n * 4. Warns about env variables in .env files that aren't used by any config\n */\n\nimport { loadEnvConfig } from \"@next/env\";\nimport { Glob } from \"bun\";\nimport path from \"path\";\n\n// ANSI colors\nconst green = (s: string) => `\\x1b[32m${s}\\x1b[0m`;\nconst yellow = (s: string) => `\\x1b[33m${s}\\x1b[0m`;\nconst red = (s: string) => `\\x1b[31m${s}\\x1b[0m`;\nconst dim = (s: string) => `\\x1b[2m${s}\\x1b[0m`;\nconst bold = (s: string) => `\\x1b[1m${s}\\x1b[0m`;\n\n// Parse CLI args\nfunction parseArgs(): { environment?: string } {\n  const args = process.argv.slice(2);\n  const result: { environment?: string } = {};\n\n  for (const arg of args) {\n    if (arg.startsWith(\"--environment=\")) {\n      result.environment = arg.split(\"=\")[1];\n    }\n  }\n\n  return result;\n}\n\n// Track which env vars are referenced by configs\nconst referencedEnvVars = new Set<string>();\n\n// Patch process.env to track access\nfunction trackEnvAccess() {\n  const originalEnv = process.env;\n  const handler: ProxyHandler<NodeJS.ProcessEnv> = {\n    get(target, prop) {\n      if (typeof prop === \"string\" && !prop.startsWith(\"_\")) {\n        referencedEnvVars.add(prop);\n      }\n      return Reflect.get(target, prop);\n    },\n  };\n  // @ts-expect-error - replacing process.env with proxy\n  process.env = new Proxy(originalEnv, handler);\n}\n\nasync function main() {\n  const args = parseArgs();\n  const projectDir = process.cwd();\n\n  console.log(bold(\"\\nðŸ” Environment Configuration Validator\\n\"));\n\n  // Set NODE_ENV if environment specified\n  const environment = args.environment ?? process.env.NODE_ENV ?? \"development\";\n  process.env.NODE_ENV = environment;\n  console.log(dim(`  Environment: ${environment}\\n`));\n\n  // Load env files\n  // Second param `dev` tells loadEnvConfig to load .env.development files\n  const isDev = environment === \"development\";\n  console.log(dim(\"  Loading environment files...\"));\n\n  const loadedEnvFiles: string[] = [];\n  const { combinedEnv, loadedEnvFiles: files } = loadEnvConfig(\n    projectDir,\n    isDev,\n  );\n\n  for (const file of files) {\n    loadedEnvFiles.push(file.path);\n    console.log(dim(`    âœ“ ${path.relative(projectDir, file.path)}`));\n  }\n\n  if (loadedEnvFiles.length === 0) {\n    console.log(dim(\"    No .env files found\"));\n  }\n\n  console.log(\"\");\n\n  // Start tracking env access before importing configs\n  trackEnvAccess();\n\n  // Find all config.ts files\n  const configGlob = new Glob(\"src/lib/*/config.ts\");\n  const configFiles: string[] = [];\n\n  for await (const file of configGlob.scan(projectDir)) {\n    configFiles.push(file);\n  }\n\n  if (configFiles.length === 0) {\n    console.log(yellow(\"  âš  No config.ts files found in src/lib/*/\\n\"));\n    process.exit(0);\n  }\n\n  console.log(dim(`  Found ${configFiles.length} config files:\\n`));\n\n  // Validate each config\n  const errors: { file: string; error: Error }[] = [];\n  const validated: string[] = [];\n\n  for (const configFile of configFiles) {\n    const relativePath = configFile;\n    const absolutePath = path.join(projectDir, configFile);\n\n    try {\n      // Import the config module - this triggers validation\n      await import(absolutePath);\n      console.log(green(`  âœ“ ${relativePath}`));\n      validated.push(relativePath);\n    } catch (error) {\n      if (error instanceof Error) {\n        // Check if it's a disabled feature flag (not an error)\n        if (error.message.includes(\"isEnabled: false\")) {\n          console.log(dim(`  â—‹ ${relativePath} (feature disabled)`));\n          validated.push(relativePath);\n        } else {\n          console.log(red(`  âœ— ${relativePath}`));\n          errors.push({ file: relativePath, error });\n        }\n      }\n    }\n  }\n\n  console.log(\"\");\n\n  // Report validation errors\n  if (errors.length > 0) {\n    console.log(red(bold(\"Validation Errors:\\n\")));\n\n    for (const { file, error } of errors) {\n      console.log(red(`  ${file}:`));\n      // Extract the actual error message\n      const message = error.message.split(\"\\n\").slice(0, 3).join(\"\\n    \");\n      console.log(red(`    ${message}\\n`));\n    }\n  }\n\n  // Find unused env variables (in .env files but not referenced by configs)\n  const envVarsInFiles = new Set<string>();\n\n  // Parse loaded env files to get all defined variables\n  for (const envFile of loadedEnvFiles) {\n    try {\n      const content = await Bun.file(envFile).text();\n      const lines = content.split(\"\\n\");\n\n      for (const line of lines) {\n        const trimmed = line.trim();\n        // Skip comments and empty lines\n        if (!trimmed || trimmed.startsWith(\"#\")) continue;\n\n        // Extract variable name (before = sign)\n        const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)\\s*=/);\n        if (match) {\n          envVarsInFiles.add(match[1]);\n        }\n      }\n    } catch {\n      // Ignore file read errors\n    }\n  }\n\n  // Common system/framework vars to ignore\n  const ignoredVars = new Set([\n    // System\n    \"NODE_ENV\",\n    \"PATH\",\n    \"HOME\",\n    \"USER\",\n    \"SHELL\",\n    \"TERM\",\n    \"LANG\",\n    \"PWD\",\n    \"OLDPWD\",\n    \"HOSTNAME\",\n    \"LOGNAME\",\n    \"TMPDIR\",\n    \"XDG_CONFIG_HOME\",\n    \"XDG_DATA_HOME\",\n    \"XDG_CACHE_HOME\",\n    \"CI\",\n    \"TZ\",\n    // Vercel\n    \"VERCEL\",\n    \"VERCEL_ENV\",\n    \"VERCEL_URL\",\n    \"VERCEL_REGION\",\n    \"VERCEL_TARGET_ENV\",\n    \"VERCEL_GIT_COMMIT_SHA\",\n    \"VERCEL_GIT_COMMIT_MESSAGE\",\n    \"VERCEL_GIT_COMMIT_AUTHOR_LOGIN\",\n    \"VERCEL_GIT_COMMIT_AUTHOR_NAME\",\n    \"VERCEL_GIT_PREVIOUS_SHA\",\n    \"VERCEL_GIT_PROVIDER\",\n    \"VERCEL_GIT_REPO_ID\",\n    \"VERCEL_GIT_REPO_OWNER\",\n    \"VERCEL_GIT_REPO_SLUG\",\n    \"VERCEL_GIT_COMMIT_REF\",\n    \"VERCEL_GIT_PULL_REQUEST_ID\",\n    // Build tools (Turbo, NX)\n    \"TURBO_CACHE\",\n    \"TURBO_REMOTE_ONLY\",\n    \"TURBO_RUN_SUMMARY\",\n    \"TURBO_DOWNLOAD_LOCAL_ENABLED\",\n    \"NX_DAEMON\",\n  ]);\n\n  // Find vars in .env files but not referenced by configs\n  const unusedVars: { name: string; files: string[] }[] = [];\n\n  for (const envVar of envVarsInFiles) {\n    if (ignoredVars.has(envVar)) continue;\n    if (referencedEnvVars.has(envVar)) continue;\n\n    // Find which files define this var\n    const definingFiles: string[] = [];\n    for (const envFile of loadedEnvFiles) {\n      try {\n        const content = await Bun.file(envFile).text();\n        if (new RegExp(`^${envVar}\\\\s*=`, \"m\").test(content)) {\n          definingFiles.push(path.relative(projectDir, envFile));\n        }\n      } catch {\n        // Ignore\n      }\n    }\n\n    if (definingFiles.length > 0) {\n      unusedVars.push({ name: envVar, files: definingFiles });\n    }\n  }\n\n  // Report unused vars\n  if (unusedVars.length > 0) {\n    console.log(yellow(bold(\"Unused Environment Variables:\\n\")));\n    console.log(\n      dim(\n        \"  These variables are defined in .env files but not used by any config:\\n\",\n      ),\n    );\n\n    for (const { name, files } of unusedVars.sort((a, b) =>\n      a.name.localeCompare(b.name),\n    )) {\n      console.log(yellow(`  âš  ${name}`));\n      console.log(dim(`    defined in: ${files.join(\", \")}`));\n    }\n\n    console.log(\"\");\n  }\n\n  // Summary\n  console.log(bold(\"Summary:\\n\"));\n  console.log(`  Configs validated: ${green(String(validated.length))}`);\n  console.log(\n    `  Validation errors: ${errors.length > 0 ? red(String(errors.length)) : green(\"0\")}`,\n  );\n  console.log(\n    `  Unused env vars:   ${unusedVars.length > 0 ? yellow(String(unusedVars.length)) : green(\"0\")}`,\n  );\n  console.log(\"\");\n\n  // Exit with error code if validation failed\n  if (errors.length > 0) {\n    process.exit(1);\n  }\n}\n\nmain().catch((error) => {\n  console.error(red(\"Unexpected error:\"), error);\n  process.exit(1);\n});\n",
      "type": "registry:lib",
      "target": "scripts/validate-env.ts"
    }
  ],
  "docs": "Add 'env:validate': 'bun run scripts/validate-env.ts' to your package.json scripts. Run with --environment=development or --environment=production.",
  "type": "registry:lib"
}
