{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "load-config",
  "title": "Environment Config Loader",
  "description": "Type-safe environment variable loading with Zod validation, runtime protection for server-only config, and full TypeScript inference.",
  "dependencies": ["zod"],
  "files": [
    {
      "path": "src/lib/common/load-config.ts",
      "content": "import { z } from \"zod\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Config with feature flag enabled - includes validated config data */\ntype EnabledConfig<T> = T & { isEnabled: true };\n\n/** Config with feature flag disabled - no config data available */\ntype DisabledConfig = { isEnabled: false };\n\n/** Optional feature config - either enabled with data or disabled */\nexport type FeatureConfig<T> = EnabledConfig<T> | DisabledConfig;\n\n/** Env value: string shorthand or full object with schema */\ntype EnvValue = string | { env: string; schema: z.ZodTypeAny };\n\n/** Infer the output type from an EnvValue */\ntype InferEnvValue<T> = T extends string\n  ? string\n  : T extends { schema: infer S }\n    ? S extends z.ZodTypeAny\n      ? z.infer<S>\n      : never\n    : never;\n\n/** Infer the full config type from an env record */\ntype InferEnv<T extends Record<string, EnvValue>> = {\n  [K in keyof T]: InferEnvValue<T[K]>;\n};\n\n/** Options for loadConfig without a feature flag (required config) */\ntype LoadConfigOptionsRequired<T extends Record<string, EnvValue>> = {\n  name?: string;\n  env: T;\n};\n\n/** Options for loadConfig with a feature flag (optional config) */\ntype LoadConfigOptionsOptional<T extends Record<string, EnvValue>> = {\n  name?: string;\n  flag: string;\n  env: T;\n};\n\n// =============================================================================\n// Errors\n// =============================================================================\n\n/**\n * Error thrown when configuration validation fails.\n */\nexport class InvalidConfigurationError extends Error {\n  constructor(message: string, featureName?: string) {\n    const feature = featureName ? ` for ${featureName}` : \"\";\n    super(\n      `Configuration validation error${feature}! Did you correctly set all required environment variables in .env file?\\n - ${message}`,\n    );\n    this.name = \"InvalidConfigurationError\";\n  }\n}\n\n/**\n * Error thrown when server-only config is accessed on the client.\n */\nexport class ServerConfigClientAccessError extends Error {\n  constructor(key: string, envVarName: string) {\n    super(\n      `Attempted to access server-only config '${key}' (${envVarName}) on client. ` +\n        `Use a NEXT_PUBLIC_* env var to expose to client, or ensure this code only runs on server.`,\n    );\n    this.name = \"ServerConfigClientAccessError\";\n  }\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\n/**\n * Checks if a flag env var is set to a truthy value.\n */\nfunction isFlagEnabled(flag: string | undefined): boolean {\n  if (!flag) return false;\n  return [\"true\", \"1\", \"yes\"].includes(flag.toLowerCase());\n}\n\n/**\n * Normalizes an EnvValue to { env, schema } form.\n */\nfunction normalizeEnvValue(value: EnvValue): {\n  env: string;\n  schema: z.ZodTypeAny;\n} {\n  return typeof value === \"string\" ? { env: value, schema: z.string() } : value;\n}\n\n/**\n * Creates a Proxy that throws when server-only config is accessed on client.\n */\nfunction createConfigProxy<T extends object>(\n  data: T,\n  envVarNames: Record<string, string>,\n): T {\n  // On server, no proxy needed\n  if (typeof window === \"undefined\") {\n    return data;\n  }\n\n  return new Proxy(data, {\n    get(target, prop, receiver) {\n      // Allow symbols, isEnabled, and prototype methods\n      if (\n        typeof prop === \"symbol\" ||\n        prop === \"isEnabled\" ||\n        !(prop in target)\n      ) {\n        return Reflect.get(target, prop, receiver);\n      }\n\n      const envVarName = envVarNames[prop];\n      if (envVarName && !envVarName.startsWith(\"NEXT_PUBLIC_\")) {\n        throw new ServerConfigClientAccessError(prop, envVarName);\n      }\n\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\n// =============================================================================\n// loadConfig\n// =============================================================================\n\n/**\n * Loads and validates environment configuration with type safety and runtime protection.\n *\n * **Features:**\n * - Type-safe config from env vars with full inference\n * - Optional feature flags for conditional configs\n * - Runtime protection: throws when server-only config accessed on client\n * - Shorthand (string) or full form ({ env, schema }) for each key\n *\n * @example Required config\n * ```ts\n * export const databaseConfig = loadConfig({\n *   env: {\n *     url: 'DATABASE_URL',\n *     poolSize: { env: 'DATABASE_POOL_SIZE', schema: z.coerce.number().default(10) },\n *   },\n * });\n * // Type: { url: string; poolSize: number }\n * ```\n *\n * @example Optional feature config\n * ```ts\n * export const sentryConfig = loadConfig({\n *   name: 'Sentry',\n *   flag: 'ENABLE_SENTRY',\n *   env: {\n *     dsn: 'NEXT_PUBLIC_SENTRY_DSN',\n *     project: 'NEXT_PUBLIC_SENTRY_PROJECT',\n *     token: 'SENTRY_AUTH_TOKEN',\n *   },\n * });\n * // Type: FeatureConfig<{ dsn: string; project: string; token: string }>\n *\n * // Usage\n * if (sentryConfig.isEnabled) {\n *   initSentry(sentryConfig.dsn); // ✓ works (NEXT_PUBLIC_*)\n *   console.log(sentryConfig.token); // ✗ throws on client (server-only)\n * }\n * ```\n */\nexport function loadConfig<T extends Record<string, EnvValue>>(\n  options: LoadConfigOptionsRequired<T>,\n): InferEnv<T>;\nexport function loadConfig<T extends Record<string, EnvValue>>(\n  options: LoadConfigOptionsOptional<T>,\n): FeatureConfig<InferEnv<T>>;\nexport function loadConfig<T extends Record<string, EnvValue>>(\n  options: LoadConfigOptionsRequired<T> | LoadConfigOptionsOptional<T>,\n): InferEnv<T> | FeatureConfig<InferEnv<T>> {\n  const { name, env } = options;\n  const flag = \"flag\" in options ? options.flag : undefined;\n\n  // If feature flag provided and not enabled, return disabled\n  if (flag !== undefined && !isFlagEnabled(process.env[flag])) {\n    return { isEnabled: false };\n  }\n\n  // Build config object and track env var names for proxy\n  const config: Record<string, unknown> = {};\n  const envVarNames: Record<string, string> = {};\n\n  for (const [key, value] of Object.entries(env)) {\n    const { env: envVarName, schema } = normalizeEnvValue(value);\n    envVarNames[key] = envVarName;\n\n    const rawValue = process.env[envVarName];\n    const result = schema.safeParse(rawValue);\n\n    if (!result.success) {\n      const issue = result.error.issues[0];\n      // Generate helpful error message\n      const message =\n        rawValue === undefined\n          ? `${envVarName} must be defined.`\n          : `${envVarName} is invalid: ${issue?.message ?? \"validation failed\"}`;\n      throw new InvalidConfigurationError(message, name);\n    }\n\n    config[key] = result.data;\n  }\n\n  // Wrap with proxy for client-side protection\n  const proxiedConfig = createConfigProxy(config, envVarNames);\n\n  // Return with isEnabled if feature flag was provided\n  if (flag !== undefined) {\n    return Object.assign(proxiedConfig, {\n      isEnabled: true as const,\n    }) as FeatureConfig<InferEnv<T>>;\n  }\n\n  return proxiedConfig as InferEnv<T>;\n}\n",
      "type": "registry:lib",
      "target": "lib/common/load-config.ts"
    }
  ],
  "type": "registry:lib"
}
