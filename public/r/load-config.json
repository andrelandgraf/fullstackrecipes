{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "load-config",
  "title": "Environment Config Loader",
  "description": "Type-safe environment variable loading with Zod validation, runtime protection for server-only config, and full TypeScript inference.",
  "dependencies": ["zod"],
  "files": [
    {
      "path": "src/lib/common/load-config.ts",
      "content": "import { z } from \"zod\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Config with feature flag enabled - includes validated config data */\ntype EnabledConfig<T> = T & { isEnabled: true };\n\n/** Config with feature flag disabled - no config data available */\ntype DisabledConfig = { isEnabled: false };\n\n/** Optional feature config - either enabled with data or disabled */\nexport type FeatureConfig<T> = EnabledConfig<T> | DisabledConfig;\n\n/**\n * Conditional optional: this var is optional if the specified env var(s) are set.\n * - `true` - always optional\n * - `false` | `undefined` - required\n * - `'OTHER_VAR'` - optional if OTHER_VAR is set\n * - `['VAR_A', 'VAR_B']` - optional if any of the listed vars are set\n */\ntype ConditionalOptional = boolean | string | string[];\n\n/** Full env value object with all options */\ntype EnvValueFull = {\n  env: string;\n  schema?: z.ZodTypeAny;\n  optional?: ConditionalOptional;\n};\n\n/** Env value: string shorthand or full object with schema and optional */\ntype EnvValue = string | EnvValueFull;\n\n/** Infer the output type from an EnvValue */\ntype InferEnvValue<T> = T extends string\n  ? string\n  : T extends { optional: true }\n    ? T extends { schema: infer S }\n      ? S extends z.ZodTypeAny\n        ? z.infer<S> | undefined\n        : string | undefined\n      : string | undefined\n    : T extends { optional: string | string[] }\n      ? T extends { schema: infer S }\n        ? S extends z.ZodTypeAny\n          ? z.infer<S> | undefined\n          : string | undefined\n        : string | undefined\n      : T extends { schema: infer S }\n        ? S extends z.ZodTypeAny\n          ? z.infer<S>\n          : never\n        : string;\n\n/** Infer the full config type from an env record */\ntype InferEnv<T extends Record<string, EnvValue>> = {\n  [K in keyof T]: InferEnvValue<T[K]>;\n};\n\n/** Options for loadConfig without a feature flag (required config) */\ntype LoadConfigOptionsRequired<T extends Record<string, EnvValue>> = {\n  name?: string;\n  env: T;\n};\n\n/** Options for loadConfig with a feature flag (optional config) */\ntype LoadConfigOptionsOptional<T extends Record<string, EnvValue>> = {\n  name?: string;\n  flag: string;\n  env: T;\n};\n\n// =============================================================================\n// Errors\n// =============================================================================\n\n/**\n * Error thrown when configuration validation fails.\n */\nexport class InvalidConfigurationError extends Error {\n  constructor(message: string, featureName?: string) {\n    const feature = featureName ? ` for ${featureName}` : \"\";\n    super(\n      `Configuration validation error${feature}! Did you correctly set all required environment variables in .env file?\\n - ${message}`,\n    );\n    this.name = \"InvalidConfigurationError\";\n  }\n}\n\n/**\n * Error thrown when server-only config is accessed on the client.\n */\nexport class ServerConfigClientAccessError extends Error {\n  constructor(key: string, envVarName: string) {\n    super(\n      `Attempted to access server-only config '${key}' (${envVarName}) on client. ` +\n        `Use a NEXT_PUBLIC_* env var to expose to client, or ensure this code only runs on server.`,\n    );\n    this.name = \"ServerConfigClientAccessError\";\n  }\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\n/**\n * Checks if a flag env var is set to a truthy value.\n */\nfunction isFlagEnabled(flag: string | undefined): boolean {\n  if (!flag) return false;\n  return [\"true\", \"1\", \"yes\"].includes(flag.toLowerCase());\n}\n\n/**\n * Normalizes an EnvValue to full form with env, schema, and optional.\n */\nfunction normalizeEnvValue(value: EnvValue): {\n  env: string;\n  schema: z.ZodTypeAny;\n  optional: ConditionalOptional | undefined;\n} {\n  if (typeof value === \"string\") {\n    return { env: value, schema: z.string(), optional: undefined };\n  }\n  return {\n    env: value.env,\n    schema: value.schema ?? z.string(),\n    optional: value.optional,\n  };\n}\n\n/**\n * Checks if a conditional optional is satisfied (i.e., the var can be skipped).\n * Returns true if the variable is optional and may be missing.\n */\nfunction isOptionalSatisfied(\n  optional: ConditionalOptional | undefined,\n): boolean {\n  if (optional === undefined || optional === false) {\n    return false; // required\n  }\n  if (optional === true) {\n    return true; // always optional\n  }\n  // Check if any of the fallback env vars are set\n  const fallbacks = Array.isArray(optional) ? optional : [optional];\n  return fallbacks.some((envVar) => {\n    const value = process.env[envVar];\n    return value !== undefined && value !== \"\";\n  });\n}\n\n/**\n * Creates a Proxy that throws when server-only config is accessed on client.\n */\nfunction createConfigProxy<T extends object>(\n  data: T,\n  envVarNames: Record<string, string>,\n): T {\n  // On server, no proxy needed\n  if (typeof window === \"undefined\") {\n    return data;\n  }\n\n  return new Proxy(data, {\n    get(target, prop, receiver) {\n      // Allow symbols, isEnabled, and prototype methods\n      if (\n        typeof prop === \"symbol\" ||\n        prop === \"isEnabled\" ||\n        !(prop in target)\n      ) {\n        return Reflect.get(target, prop, receiver);\n      }\n\n      const envVarName = envVarNames[prop];\n      if (envVarName && !envVarName.startsWith(\"NEXT_PUBLIC_\")) {\n        throw new ServerConfigClientAccessError(prop, envVarName);\n      }\n\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\n// =============================================================================\n// loadConfig\n// =============================================================================\n\n/**\n * Loads and validates environment configuration with type safety and runtime protection.\n *\n * **Features:**\n * - Type-safe config from env vars with full inference\n * - Optional feature flags for conditional configs\n * - Conditional optional: \"either or\" env vars with `optional: 'OTHER_VAR'`\n * - Runtime protection: throws when server-only config accessed on client\n * - Shorthand (string) or full form ({ env, schema, optional }) for each key\n *\n * @example Required config\n * ```ts\n * export const databaseConfig = loadConfig({\n *   env: {\n *     url: 'DATABASE_URL',\n *     poolSize: { env: 'DATABASE_POOL_SIZE', schema: z.coerce.number().default(10) },\n *   },\n * });\n * // Type: { url: string; poolSize: number }\n * ```\n *\n * @example Either-or env vars (at least one required)\n * ```ts\n * export const aiConfig = loadConfig({\n *   flag: 'ENABLE_AI_GATEWAY',\n *   env: {\n *     oidcToken: { env: 'VERCEL_OIDC_TOKEN', optional: 'AI_GATEWAY_API_KEY' },\n *     apiKey: { env: 'AI_GATEWAY_API_KEY', optional: 'VERCEL_OIDC_TOKEN' },\n *   },\n * });\n * // Type: FeatureConfig<{ oidcToken?: string; apiKey?: string }>\n * // Runtime: at least one is guaranteed to be set\n * ```\n *\n * @example Optional feature config\n * ```ts\n * export const sentryConfig = loadConfig({\n *   name: 'Sentry',\n *   flag: 'ENABLE_SENTRY',\n *   env: {\n *     dsn: 'NEXT_PUBLIC_SENTRY_DSN',\n *     project: 'NEXT_PUBLIC_SENTRY_PROJECT',\n *     token: 'SENTRY_AUTH_TOKEN',\n *   },\n * });\n * // Type: FeatureConfig<{ dsn: string; project: string; token: string }>\n *\n * // Usage\n * if (sentryConfig.isEnabled) {\n *   initSentry(sentryConfig.dsn); // ✓ works (NEXT_PUBLIC_*)\n *   console.log(sentryConfig.token); // ✗ throws on client (server-only)\n * }\n * ```\n */\nexport function loadConfig<T extends Record<string, EnvValue>>(\n  options: LoadConfigOptionsRequired<T>,\n): InferEnv<T>;\nexport function loadConfig<T extends Record<string, EnvValue>>(\n  options: LoadConfigOptionsOptional<T>,\n): FeatureConfig<InferEnv<T>>;\nexport function loadConfig<T extends Record<string, EnvValue>>(\n  options: LoadConfigOptionsRequired<T> | LoadConfigOptionsOptional<T>,\n): InferEnv<T> | FeatureConfig<InferEnv<T>> {\n  const { name, env } = options;\n  const flag = \"flag\" in options ? options.flag : undefined;\n\n  // If feature flag provided and not enabled, return disabled\n  if (flag !== undefined && !isFlagEnabled(process.env[flag])) {\n    return { isEnabled: false };\n  }\n\n  // Build config object and track env var names for proxy\n  const config: Record<string, unknown> = {};\n  const envVarNames: Record<string, string> = {};\n\n  for (const [key, value] of Object.entries(env)) {\n    const { env: envVarName, schema, optional } = normalizeEnvValue(value);\n    envVarNames[key] = envVarName;\n\n    const rawValue = process.env[envVarName];\n\n    // Check if this var can be skipped (optional or fallback exists)\n    if (rawValue === undefined && isOptionalSatisfied(optional)) {\n      config[key] = undefined;\n      continue;\n    }\n\n    const result = schema.safeParse(rawValue);\n\n    if (!result.success) {\n      const issue = result.error.issues[0];\n      // Generate helpful error message\n      let message: string;\n      if (rawValue === undefined) {\n        // Include fallback info in error message for conditional optionals\n        if (typeof optional === \"string\") {\n          message = `Either ${envVarName} or ${optional} must be defined.`;\n        } else if (Array.isArray(optional) && optional.length > 0) {\n          message = `Either ${envVarName} or one of [${optional.join(\", \")}] must be defined.`;\n        } else {\n          message = `${envVarName} must be defined.`;\n        }\n      } else {\n        message = `${envVarName} is invalid: ${issue?.message ?? \"validation failed\"}`;\n      }\n      throw new InvalidConfigurationError(message, name);\n    }\n\n    config[key] = result.data;\n  }\n\n  // Wrap with proxy for client-side protection\n  const proxiedConfig = createConfigProxy(config, envVarNames);\n\n  // Return with isEnabled if feature flag was provided\n  if (flag !== undefined) {\n    return Object.assign(proxiedConfig, {\n      isEnabled: true as const,\n    }) as FeatureConfig<InferEnv<T>>;\n  }\n\n  return proxiedConfig as InferEnv<T>;\n}\n",
      "type": "registry:lib",
      "target": "lib/common/load-config.ts"
    }
  ],
  "type": "registry:lib"
}
