{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "load-config",
  "title": "Environment Config Loader",
  "description": "Type-safe environment variable loading with Zod validation, runtime protection for server-only config, and full TypeScript inference.",
  "dependencies": ["zod"],
  "files": [
    {
      "path": "src/lib/common/load-config.ts",
      "content": "import { z } from \"zod\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Simple env value: just the value from process.env */\ntype EnvValueSimple = string | undefined;\n\n/**\n * Conditional optional: this var is optional if the condition is met.\n * - `true` - always optional\n * - `false` | `undefined` - required\n * - `string` - optional if that key in the same section has a value\n * - `string[]` - optional if any of those keys have values\n */\ntype ConditionalOptional = boolean | string | string[];\n\n/** Full env value object with all options */\ntype EnvValueFull = {\n  value: string | undefined;\n  schema?: z.ZodTypeAny;\n  optional?: ConditionalOptional;\n};\n\n/** Env value: simple (just the value) or full object with schema and optional */\ntype EnvValue = EnvValueSimple | EnvValueFull;\n\n/** Record of env values */\ntype EnvRecord = Record<string, EnvValue>;\n\n/** Infer the output type from an EnvValue */\ntype InferEnvValue<T> = T extends string\n  ? string\n  : T extends undefined\n    ? string // Required by default, will throw if undefined\n    : T extends { optional: true }\n      ? T extends { schema: infer S }\n        ? S extends z.ZodTypeAny\n          ? z.infer<S> | undefined\n          : string | undefined\n        : string | undefined\n      : T extends { optional: string | string[] }\n        ? T extends { schema: infer S }\n          ? S extends z.ZodTypeAny\n            ? z.infer<S> | undefined\n            : string | undefined\n          : string | undefined\n        : T extends { schema: infer S }\n          ? S extends z.ZodTypeAny\n            ? z.infer<S>\n            : never\n          : string;\n\n/** Infer the full config type from an env record */\ntype InferEnvRecord<T extends EnvRecord> = {\n  [K in keyof T]: InferEnvValue<T[K]>;\n};\n\n/** Base options for loadConfig */\ntype LoadConfigOptionsBase<\n  TServer extends EnvRecord = EnvRecord,\n  TPublic extends EnvRecord = EnvRecord,\n> = {\n  name?: string;\n  server?: TServer;\n  public?: TPublic;\n};\n\n/** Options for loadConfig without a feature flag (required config) */\ntype LoadConfigOptionsRequired<\n  TServer extends EnvRecord = EnvRecord,\n  TPublic extends EnvRecord = EnvRecord,\n> = LoadConfigOptionsBase<TServer, TPublic>;\n\n/** Options for loadConfig with a feature flag (optional config) */\ntype LoadConfigOptionsOptional<\n  TServer extends EnvRecord = EnvRecord,\n  TPublic extends EnvRecord = EnvRecord,\n> = LoadConfigOptionsBase<TServer, TPublic> & {\n  flag: string | undefined;\n};\n\n/** Config result with server and public sections */\ntype ConfigResult<\n  TServer extends EnvRecord,\n  TPublic extends EnvRecord,\n> = (TServer extends EnvRecord ? { server: InferEnvRecord<TServer> } : object) &\n  (TPublic extends EnvRecord ? { public: InferEnvRecord<TPublic> } : object);\n\n/** Config with feature flag enabled */\ntype EnabledConfig<\n  TServer extends EnvRecord,\n  TPublic extends EnvRecord,\n> = ConfigResult<TServer, TPublic> & { isEnabled: true };\n\n/** Config with feature flag disabled */\ntype DisabledConfig = { isEnabled: false };\n\n/** Optional feature config */\nexport type FeatureConfig<\n  TServer extends EnvRecord,\n  TPublic extends EnvRecord,\n> = EnabledConfig<TServer, TPublic> | DisabledConfig;\n\n// =============================================================================\n// Errors\n// =============================================================================\n\n/**\n * Error thrown when configuration validation fails.\n */\nexport class InvalidConfigurationError extends Error {\n  constructor(message: string, featureName?: string) {\n    const feature = featureName ? ` for ${featureName}` : \"\";\n    super(\n      `Configuration validation error${feature}! Did you correctly set all required environment variables in your .env* file?\\n - ${message}`,\n    );\n    this.name = \"InvalidConfigurationError\";\n  }\n}\n\n/**\n * Error thrown when server-only config is accessed on the client.\n */\nexport class ServerConfigClientAccessError extends Error {\n  constructor(key: string) {\n    super(\n      `Attempted to access server-only config 'server.${key}' on client. ` +\n        `Move this value to 'public' if it needs client access, or ensure this code only runs on server.`,\n    );\n    this.name = \"ServerConfigClientAccessError\";\n  }\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\n/**\n * Checks if a flag value is truthy.\n */\nfunction isFlagEnabled(flag: string | undefined): boolean {\n  if (!flag) return false;\n  return [\"true\", \"1\", \"yes\"].includes(flag.toLowerCase());\n}\n\n/**\n * Normalizes an EnvValue to full form with value, schema, and optional.\n */\nfunction normalizeEnvValue(value: EnvValue): {\n  value: string | undefined;\n  schema: z.ZodTypeAny;\n  optional: ConditionalOptional | undefined;\n} {\n  if (typeof value === \"string\" || value === undefined) {\n    return { value, schema: z.string(), optional: undefined };\n  }\n  return {\n    value: value.value,\n    schema: value.schema ?? z.string(),\n    optional: value.optional,\n  };\n}\n\n/**\n * Checks if a conditional optional is satisfied.\n * @param optional - The optional condition\n * @param sectionValues - The values in the same section to check against\n */\nfunction isOptionalSatisfied(\n  optional: ConditionalOptional | undefined,\n  sectionValues: Record<string, string | undefined>,\n): boolean {\n  if (optional === undefined || optional === false) {\n    return false; // required\n  }\n  if (optional === true) {\n    return true; // always optional\n  }\n  // Check if any of the fallback keys in the same section have values\n  const fallbacks = Array.isArray(optional) ? optional : [optional];\n  return fallbacks.some((key) => {\n    const value = sectionValues[key];\n    return value !== undefined && value !== \"\";\n  });\n}\n\n/**\n * Creates a Proxy that throws when server config is accessed on client.\n */\nfunction createServerProxy<T extends object>(data: T): T {\n  // On server, no proxy needed\n  if (typeof window === \"undefined\") {\n    return data;\n  }\n\n  return new Proxy(data, {\n    get(target, prop, receiver) {\n      // Allow symbols and prototype methods\n      if (typeof prop === \"symbol\" || !(prop in target)) {\n        return Reflect.get(target, prop, receiver);\n      }\n\n      throw new ServerConfigClientAccessError(String(prop));\n    },\n  });\n}\n\n/**\n * Processes an env record section and returns validated values.\n */\nfunction processSection(\n  section: EnvRecord,\n  sectionName: \"server\" | \"public\",\n  featureName?: string,\n): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  // First pass: collect raw values for conditional optional checks\n  const rawValues: Record<string, string | undefined> = {};\n  for (const [key, envValue] of Object.entries(section)) {\n    const { value } = normalizeEnvValue(envValue);\n    rawValues[key] = value;\n  }\n\n  // Second pass: validate and transform\n  for (const [key, envValue] of Object.entries(section)) {\n    const { value, schema, optional } = normalizeEnvValue(envValue);\n\n    // Check if this var can be skipped (optional or fallback exists)\n    if (value === undefined && isOptionalSatisfied(optional, rawValues)) {\n      result[key] = undefined;\n      continue;\n    }\n\n    const parseResult = schema.safeParse(value);\n\n    if (!parseResult.success) {\n      const issue = parseResult.error.issues[0];\n      let message: string;\n\n      if (value === undefined) {\n        if (typeof optional === \"string\") {\n          message = `Either ${sectionName}.${key} or ${sectionName}.${optional} must be defined.`;\n        } else if (Array.isArray(optional) && optional.length > 0) {\n          const fallbackKeys = optional.map((k) => `${sectionName}.${k}`);\n          message = `Either ${sectionName}.${key} or one of [${fallbackKeys.join(\", \")}] must be defined.`;\n        } else {\n          message = `${sectionName}.${key} must be defined.`;\n        }\n      } else {\n        message = `${sectionName}.${key} is invalid: ${issue?.message ?? \"validation failed\"}`;\n      }\n\n      throw new InvalidConfigurationError(message, featureName);\n    }\n\n    result[key] = parseResult.data;\n  }\n\n  return result;\n}\n\n// =============================================================================\n// loadConfig\n// =============================================================================\n\n/**\n * Loads and validates environment configuration with type safety and runtime protection.\n *\n * **Features:**\n * - Explicit `server` and `public` sections for clarity\n * - Type-safe config with full inference\n * - Optional feature flags for conditional configs\n * - Conditional optional: \"either or\" values with `optional: 'otherKey'`\n * - Runtime protection: throws when `server.*` accessed on client\n * - Values passed directly, so `NEXT_PUBLIC_*` vars are properly inlined by Next.js\n *\n * @example Basic config (no flag)\n * ```ts\n * export const dbConfig = loadConfig({\n *   server: {\n *     url: process.env.DATABASE_URL,\n *     poolSize: { value: process.env.DB_POOL_SIZE, schema: z.coerce.number().default(10) },\n *   },\n * });\n * // Type: { server: { url: string; poolSize: number } }\n * ```\n *\n * @example Feature flag with mixed server/public\n * ```ts\n * export const sentryConfig = loadConfig({\n *   name: 'Sentry',\n *   flag: process.env.NEXT_PUBLIC_ENABLE_SENTRY,\n *   server: {\n *     token: process.env.SENTRY_AUTH_TOKEN,\n *   },\n *   public: {\n *     dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,\n *     project: process.env.NEXT_PUBLIC_SENTRY_PROJECT,\n *   },\n * });\n * // Type: FeatureConfig<...>\n *\n * if (sentryConfig.isEnabled) {\n *   sentryConfig.public.dsn;     // ✓ works everywhere\n *   sentryConfig.server.token;   // ✓ server only, throws on client\n * }\n * ```\n *\n * @example Either-or values\n * ```ts\n * export const aiConfig = loadConfig({\n *   server: {\n *     oidcToken: { value: process.env.VERCEL_OIDC_TOKEN, optional: 'apiKey' },\n *     apiKey: { value: process.env.AI_API_KEY, optional: 'oidcToken' },\n *   },\n * });\n * // At least one of oidcToken or apiKey must be defined\n * ```\n */\nexport function loadConfig<\n  TServer extends EnvRecord = Record<string, never>,\n  TPublic extends EnvRecord = Record<string, never>,\n>(\n  options: LoadConfigOptionsRequired<TServer, TPublic>,\n): ConfigResult<TServer, TPublic>;\nexport function loadConfig<\n  TServer extends EnvRecord = Record<string, never>,\n  TPublic extends EnvRecord = Record<string, never>,\n>(\n  options: LoadConfigOptionsOptional<TServer, TPublic>,\n): FeatureConfig<TServer, TPublic>;\nexport function loadConfig<\n  TServer extends EnvRecord = Record<string, never>,\n  TPublic extends EnvRecord = Record<string, never>,\n>(\n  options:\n    | LoadConfigOptionsRequired<TServer, TPublic>\n    | LoadConfigOptionsOptional<TServer, TPublic>,\n): ConfigResult<TServer, TPublic> | FeatureConfig<TServer, TPublic> {\n  const { name, server, public: publicEnv } = options;\n  const flag = \"flag\" in options ? options.flag : undefined;\n  const hasFlag = \"flag\" in options;\n\n  // If feature flag provided and not enabled, return disabled\n  if (hasFlag && !isFlagEnabled(flag)) {\n    return { isEnabled: false };\n  }\n\n  // Build config\n  const result: Record<string, unknown> = {};\n  const isClient = typeof window !== \"undefined\";\n\n  if (server && Object.keys(server).length > 0) {\n    // On client, skip validation - server vars aren't available\n    // Just create a proxy that throws on any access\n    if (isClient) {\n      result.server = createServerProxy({});\n    } else {\n      const serverData = processSection(server, \"server\", name);\n      result.server = createServerProxy(serverData);\n    }\n  }\n\n  if (publicEnv && Object.keys(publicEnv).length > 0) {\n    result.public = processSection(publicEnv, \"public\", name);\n  }\n\n  // Return with isEnabled if feature flag was provided\n  if (hasFlag) {\n    return { ...result, isEnabled: true } as FeatureConfig<TServer, TPublic>;\n  }\n\n  return result as ConfigResult<TServer, TPublic>;\n}\n",
      "type": "registry:lib",
      "target": "lib/common/load-config.ts"
    }
  ],
  "type": "registry:lib"
}
