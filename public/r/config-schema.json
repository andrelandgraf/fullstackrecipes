{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "config-schema",
  "title": "Config Schema",
  "description": "Drizzle-like API for type-safe environment variable configuration with Zod validation, runtime protection for server-only config, and full TypeScript inference.",
  "dependencies": ["zod"],
  "files": [
    {
      "path": "src/lib/config/schema.ts",
      "content": "import { z } from \"zod\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Base field definition with schema type */\ntype FieldDefBase<TSchema extends z.ZodTypeAny = z.ZodString> = {\n  env: string;\n  value: string | undefined;\n  schema: TSchema;\n  isOptional: boolean;\n};\n\n/** Server field definition */\ntype ServerFieldDef<TSchema extends z.ZodTypeAny = z.ZodString> =\n  FieldDefBase<TSchema> & { _type: \"server\" };\n\n/** Public field definition */\ntype PublicFieldDef<TSchema extends z.ZodTypeAny = z.ZodString> =\n  FieldDefBase<TSchema> & { _type: \"public\" };\n\n/** Field definition union */\ntype FieldDef = ServerFieldDef<z.ZodTypeAny> | PublicFieldDef<z.ZodTypeAny>;\n\n/** Schema fields record */\ntype SchemaFields = Record<string, FieldDef>;\n\n/** Constraint result */\ntype ConstraintResult<T extends SchemaFields> = {\n  type: \"oneOf\";\n  fields: (keyof T)[];\n  satisfied: boolean;\n};\n\n/** Constraint function */\ntype Constraint<T extends SchemaFields> = (fields: T) => ConstraintResult<T>;\n\n/** Infer the output type from a FieldDef based on schema and optionality */\ntype InferField<F> =\n  F extends FieldDefBase<infer S>\n    ? F[\"isOptional\"] extends true\n      ? z.infer<S> | undefined\n      : z.infer<S>\n    : never;\n\n/** Extract server field keys */\ntype ServerKeys<T extends SchemaFields> = {\n  [K in keyof T]: T[K] extends ServerFieldDef<z.ZodTypeAny> ? K : never;\n}[keyof T];\n\n/** Extract public field keys */\ntype PublicKeys<T extends SchemaFields> = {\n  [K in keyof T]: T[K] extends PublicFieldDef<z.ZodTypeAny> ? K : never;\n}[keyof T];\n\n/** Build server section type */\ntype ServerSection<T extends SchemaFields> = {\n  [K in ServerKeys<T>]: InferField<T[K]>;\n};\n\n/** Build public section type */\ntype PublicSection<T extends SchemaFields> = {\n  [K in PublicKeys<T>]: InferField<T[K]>;\n};\n\n/** Check if there are any server fields */\ntype HasServerFields<T extends SchemaFields> =\n  ServerKeys<T> extends never ? false : true;\n\n/** Check if there are any public fields */\ntype HasPublicFields<T extends SchemaFields> =\n  PublicKeys<T> extends never ? false : true;\n\n/** Infer config result from fields (no isEnabled) */\ntype InferConfigResult<T extends SchemaFields> =\n  (HasServerFields<T> extends true ? { server: ServerSection<T> } : object) &\n    (HasPublicFields<T> extends true ? { public: PublicSection<T> } : object);\n\n/** Config with feature flag enabled */\ntype EnabledConfig<T extends SchemaFields> = InferConfigResult<T> & {\n  isEnabled: true;\n};\n\n/** Config with feature flag disabled */\ntype DisabledConfig = { isEnabled: false };\n\n/** Feature config (when flag is used) */\nexport type FeatureConfig<T extends SchemaFields> =\n  | EnabledConfig<T>\n  | DisabledConfig;\n\n/** Flag options */\ntype FlagOptions = {\n  env: string;\n  value: string | undefined;\n};\n\n/** Options object with flag (returns FeatureConfig) */\ntype ConfigOptionsWithFlag<T extends SchemaFields> = {\n  flag: FlagOptions;\n  constraints?: (schema: T) => Constraint<T>[];\n};\n\n/** Options object without flag (returns InferConfigResult) */\ntype ConfigOptionsWithoutFlag<T extends SchemaFields> = {\n  flag?: undefined;\n  constraints: (schema: T) => Constraint<T>[];\n};\n\n// =============================================================================\n// Errors\n// =============================================================================\n\n/**\n * Error thrown when configuration validation fails.\n */\nexport class InvalidConfigurationError extends Error {\n  constructor(message: string, schemaName?: string) {\n    const schema = schemaName ? ` for ${schemaName}` : \"\";\n    super(\n      `Configuration validation error${schema}! Did you correctly set all required environment variables in your .env* file?\\n - ${message}`,\n    );\n    this.name = \"InvalidConfigurationError\";\n  }\n}\n\n/**\n * Error thrown when server-only config is accessed on the client.\n */\nexport class ServerConfigClientAccessError extends Error {\n  constructor(key: string) {\n    super(\n      `Attempted to access server-only config 'server.${key}' on client. ` +\n        `Move this value to 'public' if it needs client access, or ensure this code only runs on server.`,\n    );\n    this.name = \"ServerConfigClientAccessError\";\n  }\n}\n\n// =============================================================================\n// Field Builders\n// =============================================================================\n\ntype ServerFieldOptionsBase = {\n  env: string;\n  value?: string | undefined;\n  optional?: boolean;\n};\n\ntype ServerFieldOptionsWithSchema<T extends z.ZodTypeAny> =\n  ServerFieldOptionsBase & {\n    schema: T;\n  };\n\ntype ServerFieldOptionsWithoutSchema = ServerFieldOptionsBase & {\n  schema?: undefined;\n};\n\ntype PublicFieldOptionsBase = {\n  env: string;\n  value: string | undefined; // Required for public fields (Next.js inlining)\n  optional?: boolean;\n};\n\ntype PublicFieldOptionsWithSchema<T extends z.ZodTypeAny> =\n  PublicFieldOptionsBase & {\n    schema: T;\n  };\n\ntype PublicFieldOptionsWithoutSchema = PublicFieldOptionsBase & {\n  schema?: undefined;\n};\n\n/**\n * Define a server-only config field.\n * Server fields are only accessible on the server and throw on client access.\n *\n * @example\n * ```ts\n * server({ env: \"DATABASE_URL\" })\n * server({ env: \"PORT\", schema: z.coerce.number().default(3000) })\n * server({ env: \"OPTIONAL_KEY\", optional: true })\n * ```\n */\nexport function server<T extends z.ZodTypeAny>(\n  options: ServerFieldOptionsWithSchema<T>,\n): ServerFieldDef<T>;\nexport function server(\n  options: ServerFieldOptionsWithoutSchema,\n): ServerFieldDef<z.ZodString>;\nexport function server(\n  options: ServerFieldOptionsBase & { schema?: z.ZodTypeAny },\n): ServerFieldDef<z.ZodTypeAny> {\n  const { env, value, schema = z.string(), optional = false } = options;\n\n  return {\n    _type: \"server\" as const,\n    env,\n    value: value ?? process.env[env],\n    schema,\n    isOptional: optional,\n  };\n}\n\n/**\n * Define a public config field (accessible on both server and client).\n * The value must be passed directly for Next.js to inline NEXT_PUBLIC_* variables.\n *\n * @example\n * ```ts\n * pub({ env: \"NEXT_PUBLIC_DSN\", value: process.env.NEXT_PUBLIC_DSN })\n * pub({ env: \"NEXT_PUBLIC_ENABLED\", value: process.env.NEXT_PUBLIC_ENABLED, schema: z.string().optional() })\n * ```\n */\nexport function pub<T extends z.ZodTypeAny>(\n  options: PublicFieldOptionsWithSchema<T>,\n): PublicFieldDef<T>;\nexport function pub(\n  options: PublicFieldOptionsWithoutSchema,\n): PublicFieldDef<z.ZodString>;\nexport function pub(\n  options: PublicFieldOptionsBase & { schema?: z.ZodTypeAny },\n): PublicFieldDef<z.ZodTypeAny> {\n  const { env, value, schema = z.string(), optional = false } = options;\n\n  return {\n    _type: \"public\" as const,\n    env,\n    value,\n    schema,\n    isOptional: optional,\n  };\n}\n\n// =============================================================================\n// Constraints\n// =============================================================================\n\n/**\n * Create a \"one of\" constraint.\n * At least one of the specified fields must have a value.\n *\n * @example\n * ```ts\n * configSchema(\"AI\", {\n *   oidcToken: server({ env: \"VERCEL_OIDC_TOKEN\" }),\n *   apiKey: server({ env: \"API_KEY\" }),\n * }, {\n *   constraints: (s) => [oneOf([s.oidcToken, s.apiKey])],\n * })\n * ```\n */\nexport function oneOf<T extends SchemaFields>(\n  fieldDefs: FieldDef[],\n): Constraint<T> {\n  return (allFields) => {\n    // Find which field names match the provided field defs\n    const fieldNames: (keyof T)[] = [];\n    for (const [name, field] of Object.entries(allFields)) {\n      if (fieldDefs.includes(field)) {\n        fieldNames.push(name as keyof T);\n      }\n    }\n\n    const satisfied = fieldDefs.some(\n      (field) => field.value !== undefined && field.value !== \"\",\n    );\n\n    return {\n      type: \"oneOf\",\n      fields: fieldNames,\n      satisfied,\n    };\n  };\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\n/**\n * Checks if a flag value is truthy.\n */\nfunction isFlagEnabled(flag: string | undefined): boolean {\n  if (!flag) return false;\n  return [\"true\", \"1\", \"yes\"].includes(flag.toLowerCase());\n}\n\n/**\n * Creates a Proxy that throws when server config is accessed on client.\n */\nfunction createServerProxy<T extends object>(data: T): T {\n  if (typeof window === \"undefined\") {\n    return data;\n  }\n\n  return new Proxy(data, {\n    get(target, prop, receiver) {\n      if (typeof prop === \"symbol\") {\n        return Reflect.get(target, prop, receiver);\n      }\n      throw new ServerConfigClientAccessError(String(prop));\n    },\n  });\n}\n\n// =============================================================================\n// Schema Builder\n// =============================================================================\n\n// Overload 1: No options (just name and fields)\nexport function configSchema<T extends SchemaFields>(\n  name: string,\n  fields: T,\n): InferConfigResult<T>;\n\n// Overload 2: With flag option (returns FeatureConfig)\nexport function configSchema<T extends SchemaFields>(\n  name: string,\n  fields: T,\n  options: ConfigOptionsWithFlag<T>,\n): FeatureConfig<T>;\n\n// Overload 3: With constraints but no flag (returns InferConfigResult)\nexport function configSchema<T extends SchemaFields>(\n  name: string,\n  fields: T,\n  options: ConfigOptionsWithoutFlag<T>,\n): InferConfigResult<T>;\n\n/**\n * Define a configuration schema with typed server and public fields.\n *\n * @example Basic server-only config\n * ```ts\n * const dbConfig = configSchema(\"Database\", {\n *   url: server({ env: \"DATABASE_URL\" }),\n * });\n * // Type: { server: { url: string } }\n * dbConfig.server.url\n * ```\n *\n * @example Feature flag\n * ```ts\n * const sentryConfig = configSchema(\"Sentry\", {\n *   token: server({ env: \"SENTRY_AUTH_TOKEN\" }),\n *   dsn: pub({ env: \"NEXT_PUBLIC_SENTRY_DSN\", value: process.env.NEXT_PUBLIC_SENTRY_DSN }),\n * }, {\n *   flag: { env: \"NEXT_PUBLIC_ENABLE_SENTRY\", value: process.env.NEXT_PUBLIC_ENABLE_SENTRY },\n * });\n *\n * if (sentryConfig.isEnabled) {\n *   sentryConfig.server.token;  // string\n *   sentryConfig.public.dsn;    // string\n * }\n * ```\n *\n * @example Either-or with oneOf (no flag)\n * ```ts\n * const aiConfig = configSchema(\"AI\", {\n *   oidcToken: server({ env: \"VERCEL_OIDC_TOKEN\" }),\n *   apiKey: server({ env: \"API_KEY\" }),\n * }, {\n *   constraints: (s) => [oneOf([s.oidcToken, s.apiKey])],\n * });\n * // Type: { server: { oidcToken?: string; apiKey?: string } }\n * ```\n *\n * @example Flag + constraints\n * ```ts\n * const config = configSchema(\"MyFeature\", {\n *   token: server({ env: \"TOKEN\" }),\n *   backupToken: server({ env: \"BACKUP_TOKEN\" }),\n * }, {\n *   flag: { env: \"ENABLE_FEATURE\", value: process.env.ENABLE_FEATURE },\n *   constraints: (s) => [oneOf([s.token, s.backupToken])],\n * });\n * ```\n */\nexport function configSchema<T extends SchemaFields>(\n  name: string,\n  fields: T,\n  options?: ConfigOptionsWithFlag<T> | ConfigOptionsWithoutFlag<T>,\n): InferConfigResult<T> | FeatureConfig<T> {\n  const flagOptions = options?.flag;\n  const constraintsFn = options?.constraints;\n  const hasFlag = flagOptions !== undefined;\n\n  // If flag exists and is disabled, return early\n  if (hasFlag && !isFlagEnabled(flagOptions.value)) {\n    return { isEnabled: false };\n  }\n\n  // Evaluate constraints if provided\n  const constraintList = constraintsFn ? constraintsFn(fields) : [];\n  const constraintResults = constraintList.map((c) => c(fields));\n\n  // Collect oneOf constraint results\n  const oneOfResults = constraintResults.filter(\n    (r): r is ConstraintResult<T> => r.type === \"oneOf\",\n  );\n\n  // Track which fields are covered by oneOf (making them conditionally optional)\n  const oneOfFieldNames = new Set<string>();\n\n  for (const result of oneOfResults) {\n    for (const fieldName of result.fields) {\n      oneOfFieldNames.add(fieldName as string);\n    }\n  }\n\n  const isClient = typeof window !== \"undefined\";\n\n  // Process fields\n  const serverFields: Record<string, unknown> = {};\n  const publicFields: Record<string, unknown> = {};\n\n  for (const [key, field] of Object.entries(fields)) {\n    // Skip server validation on client\n    if (field._type === \"server\" && isClient) {\n      continue;\n    }\n\n    const { value, schema, isOptional } = field;\n\n    // Check if this field is covered by a oneOf constraint\n    const isInOneOf = oneOfFieldNames.has(key);\n    let canSkipValidation = isOptional;\n\n    if (isInOneOf && value === undefined) {\n      // Check if any oneOf constraint covering this field is satisfied\n      const relevantOneOf = oneOfResults.find((r) =>\n        r.fields.includes(key as keyof T),\n      );\n      if (relevantOneOf?.satisfied) {\n        canSkipValidation = true;\n      }\n    }\n\n    // Skip validation for optional fields with undefined value\n    if (value === undefined && canSkipValidation) {\n      if (field._type === \"server\") {\n        serverFields[key] = undefined;\n      } else {\n        publicFields[key] = undefined;\n      }\n      continue;\n    }\n\n    // Validate\n    const parseResult = schema.safeParse(value);\n\n    if (!parseResult.success) {\n      const section = field._type;\n      const issue = parseResult.error.issues[0];\n      let message: string;\n\n      if (value === undefined) {\n        // Check if part of oneOf\n        if (isInOneOf) {\n          const relevantOneOf = oneOfResults.find((r) =>\n            r.fields.includes(key as keyof T),\n          );\n          if (relevantOneOf) {\n            const otherFields = relevantOneOf.fields\n              .filter((f) => f !== key)\n              .map((f) => `${section}.${String(f)}`);\n            if (otherFields.length === 1) {\n              message = `Either ${section}.${key} or ${otherFields[0]} must be defined.`;\n            } else {\n              message = `Either ${section}.${key} or one of [${otherFields.join(\", \")}] must be defined.`;\n            }\n          } else {\n            message = `${section}.${key} must be defined.`;\n          }\n        } else {\n          message = `${section}.${key} must be defined.`;\n        }\n      } else {\n        message = `${section}.${key} is invalid: ${issue?.message ?? \"validation failed\"}`;\n      }\n\n      throw new InvalidConfigurationError(message, name);\n    }\n\n    if (field._type === \"server\") {\n      serverFields[key] = parseResult.data;\n    } else {\n      publicFields[key] = parseResult.data;\n    }\n  }\n\n  // Build result\n  const result: Record<string, unknown> = {};\n\n  const hasServer = Object.values(fields).some((f) => f._type === \"server\");\n  const hasPublic = Object.values(fields).some((f) => f._type === \"public\");\n\n  if (hasServer) {\n    result.server = createServerProxy(serverFields);\n  }\n\n  if (hasPublic) {\n    result.public = publicFields;\n  }\n\n  // Return with isEnabled only if flag was provided\n  if (hasFlag) {\n    return { ...result, isEnabled: true } as FeatureConfig<T>;\n  }\n\n  return result as InferConfigResult<T>;\n}\n",
      "type": "registry:lib",
      "target": "lib/config/schema.ts"
    }
  ],
  "type": "registry:lib"
}
