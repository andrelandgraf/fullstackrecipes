{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "durable-agent",
  "title": "Durable Agent",
  "description": "AI agent class that executes streamText in a tool loop with workflow compatibility. Supports provider options, streaming control, and step-level durability via 'use step' directive.",
  "dependencies": ["ai", "@ai-sdk/provider-utils"],
  "files": [
    {
      "path": "src/lib/ai/agent.ts",
      "content": "import {\n  streamText,\n  convertToModelMessages,\n  type FinishReason,\n  type UIMessage,\n  type UIMessageChunk,\n  type ModelMessage,\n} from \"ai\";\nimport type { ProviderOptions } from \"@ai-sdk/provider-utils\";\nimport { researchTools, draftingTools } from \"./tools\";\n\ntype MessagePart = UIMessage[\"parts\"][number];\n\nexport type ToolsKey = \"research\" | \"drafting\";\n\nconst toolSets = {\n  research: researchTools,\n  drafting: draftingTools,\n} as const;\n\n/**\n * Serializable stream options (excludes callbacks like onFinish).\n */\nexport interface StreamOptions {\n  sendStart?: boolean;\n  sendFinish?: boolean;\n  sendReasoning?: boolean;\n  sendSources?: boolean;\n}\n\n/**\n * Serializable options for streamText (excludes callbacks and messages).\n */\nexport interface StepOptions {\n  model: string;\n  system: string;\n  /** Tool set key - resolved to actual tools inside the step executor */\n  tools: ToolsKey;\n  providerOptions?: ProviderOptions;\n}\n\n/**\n * All properties must be serializable for workflow compatibility.\n */\nexport interface AgentConfig {\n  stepOptions: StepOptions;\n  streamOptions?: StreamOptions;\n}\n\nexport interface AgentRunConfig {\n  /** @default 20 */\n  maxSteps?: number;\n  /** Pass getWritable() in workflows, or any WritableStream outside */\n  writable?: WritableStream<UIMessageChunk>;\n}\n\nexport interface AgentRunResult {\n  parts: MessagePart[];\n  stepCount: number;\n}\n\ninterface AgentStepResult {\n  shouldContinue: boolean;\n  responseMessage: UIMessage;\n  finishReason: FinishReason;\n}\n\ninterface StepExecutorConfig {\n  stepOptions: StepOptions;\n  streamOptions?: StreamOptions;\n  writable?: WritableStream<UIMessageChunk>;\n}\n\n/**\n * AI agent that executes streamText in a tool loop.\n *\n * Configuration is fully serializable for workflow compatibility.\n * Tools are referenced by key and resolved inside the step executor.\n *\n * @example\n * ```ts\n * const draftingAgent = new Agent({\n *   stepOptions: {\n *     model: \"google/gemini-3-pro-preview\",\n *     system: \"You are a drafting agent...\",\n *     tools: \"drafting\",\n *   },\n *   streamOptions: { sendReasoning: true },\n * });\n *\n * const { parts } = await draftingAgent.run(history, {\n *   maxSteps: 10,\n *   writable: getWritable(),\n * });\n * ```\n */\nexport class Agent {\n  constructor(private config: AgentConfig) {}\n\n  async run(\n    history: UIMessage[],\n    runConfig: AgentRunConfig = {},\n  ): Promise<AgentRunResult> {\n    const { maxSteps = 20, writable } = runConfig;\n\n    const stepConfig: StepExecutorConfig = {\n      stepOptions: this.config.stepOptions,\n      streamOptions: this.config.streamOptions,\n      writable,\n    };\n\n    let modelMessages: ModelMessage[] = convertToModelMessages(history);\n    let stepCount = 0;\n    let shouldContinue = true;\n    let allParts: MessagePart[] = [];\n\n    while (shouldContinue && stepCount < maxSteps) {\n      const result = await executeAgentStep(modelMessages, stepConfig);\n\n      allParts = [...allParts, ...result.responseMessage.parts];\n      modelMessages = [\n        ...modelMessages,\n        ...convertToModelMessages([result.responseMessage]),\n      ];\n\n      shouldContinue = result.shouldContinue;\n      stepCount++;\n    }\n\n    return { parts: allParts, stepCount };\n  }\n}\n\n/**\n * Step executor with \"use step\" directive.\n * Separated from class because \"use step\" only works in standalone functions.\n * @internal\n */\nasync function executeAgentStep(\n  messages: ModelMessage[],\n  config: StepExecutorConfig,\n): Promise<AgentStepResult> {\n  \"use step\";\n\n  const tools = toolSets[config.stepOptions.tools];\n\n  const resultStream = streamText({\n    model: config.stepOptions.model,\n    system: config.stepOptions.system,\n    tools,\n    messages,\n    providerOptions: config.stepOptions.providerOptions,\n  });\n\n  let responseMessage: UIMessage | null = null;\n\n  const uiStream = resultStream.toUIMessageStream({\n    sendStart: config.streamOptions?.sendStart ?? false,\n    sendFinish: config.streamOptions?.sendFinish ?? false,\n    sendReasoning: config.streamOptions?.sendReasoning ?? false,\n    sendSources: config.streamOptions?.sendSources ?? false,\n    onFinish: ({ responseMessage: msg }) => {\n      responseMessage = msg;\n    },\n  });\n\n  if (config.writable) {\n    await pipeToWritable(uiStream, config.writable);\n  } else {\n    await consumeStream(uiStream);\n  }\n\n  await resultStream.consumeStream();\n  const finishReason = await resultStream.finishReason;\n\n  if (!responseMessage) {\n    throw new Error(\"No response message received from stream\");\n  }\n\n  const shouldContinue = finishReason === \"tool-calls\";\n\n  return { shouldContinue, responseMessage, finishReason };\n}\n\nasync function consumeStream<T>(stream: ReadableStream<T>): Promise<void> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done) break;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nasync function pipeToWritable<T>(\n  readable: ReadableStream<T>,\n  writable: WritableStream<T>,\n): Promise<void> {\n  const writer = writable.getWriter();\n  const reader = readable.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      await writer.write(value);\n    }\n  } finally {\n    reader.releaseLock();\n    writer.releaseLock();\n  }\n}\n\nexport function createAgent(config: AgentConfig): Agent {\n  return new Agent(config);\n}\n",
      "type": "registry:lib",
      "target": "lib/ai/agent.ts"
    }
  ],
  "docs": "This agent requires tool definitions. Update the import from './tools' to match your project's tool configuration.",
  "type": "registry:lib"
}
